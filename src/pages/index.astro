---
import Base from '../layouts/Base.astro';
import { getCollection } from 'astro:content';

// collection name stays "reflections" as in your repo
const reflections = (await getCollection('reflections')).sort((a, b) => a.data.order - b.data.order);

// build-safe base path for GitHub Pages (user page → '/', project page → '/<repo>/')
const rawBase = import.meta.env.BASE_URL ?? Astro.site?.pathname ?? '/';
const base = rawBase.endsWith('/') ? rawBase : `${rawBase}/`;

// data to expose to the client script
const slugs = reflections.map(r => r.slug);
const titles = reflections.map(r => r.data.title);
---
<Base title="Reflexions-Run" noIndex={true}>
  <style>
    .wrap{max-width:1000px;margin:1.5rem auto;padding:0 1rem}
    .hint{color:#a9acb6;margin:.25rem 0 1rem}
    #game{display:block;margin:0 auto;border:1px solid #222;border-radius:8px;box-shadow:0 8px 28px rgba(0,0,0,.4)}
    .unlock-head{margin:1.6rem 0 .4rem}
    .locked{display:none}
  </style>

  <div class="wrap">
    <h1 class="page-title">Reflexions-Run</h1>
    <p class="hint">Steuerung: ← → bewegen, ↑ springen. Sammle die <b>Spiegel</b>, um Links zu den Reflexionen freizuschalten.</p>

    <!-- Game canvas -->
    <canvas id="game" width="960" height="540"></canvas>

    <!-- Unlocked links are your existing list; they start hidden (display:none) and get revealed -->
    <h3 class="unlock-head">Freigeschaltete Reflexionen</h3>
    <ul id="refList">
      {reflections.map((r) => (
        <li data-slug={r.slug} class="locked">
          <a href={`${base}reflections/${r.slug}/`} target="_blank" rel="noopener">{r.data.title}</a>
        </li>
      ))}
    </ul>
  </div>

  <!-- Phaser UMD (global) -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>

  <!-- Game + unlock logic -->
  <script type="module" define:vars={{ slugs, titles, base }}>
    // ---- helpers: localStorage unlocking ----
    const LS_KEY = 'unlockedLinks';
    function getUnlocked() {
      try { return new Set(JSON.parse(localStorage.getItem(LS_KEY) || '[]')); }
      catch { return new Set(); }
    }
    function setUnlocked(set) {
      localStorage.setItem(LS_KEY, JSON.stringify([...set]));
    }
    function unlock(slug) {
      const set = getUnlocked();
      if (!set.has(slug)) {
        set.add(slug);
        setUnlocked(set);
        revealBySlug(slug);
      }
    }
    function revealAllFromStorage() {
      const set = getUnlocked();
      set.forEach(revealBySlug);
    }
    function revealBySlug(slug) {
      const li = document.querySelector(`#refList li[data-slug="${slug}"]`);
      if (li) li.classList.remove('locked');
    }

    // reveal any previously unlocked links
    revealAllFromStorage();

    // ---- mini game ----
    // Guard: Phaser must be available globally from the UMD build
    if (!window.Phaser) {
      console.error('Phaser not found on window. Check the <script src> above.');
    } else {
      const W = 960, H = 540;
      const config = {
        type: Phaser.WEBGL,      // explicit render type fixes custom env warning
        width: W, height: H,
        canvas: document.getElementById('game'),
        physics: { default: 'arcade', arcade: { gravity: { y: 1200 }, debug: false } },
        scene: { preload, create, update }
      };
      const game = new Phaser.Game(config);

      let cursors, player, platforms, mirrors;
      const assetPath = (path) => encodeURI(`${base}assets/sprites/PNG/${path}`);

      function preload() {
        this.load.image('bg', assetPath('Backgrounds/colored_grass.png'));
        this.load.image('ground_mid', assetPath('Ground/Grass/grassMid.png'));
        this.load.image('ground_left', assetPath('Ground/Grass/grassLeft.png'));
        this.load.image('ground_right', assetPath('Ground/Grass/grassRight.png'));
        this.load.image('ground_half', assetPath('Ground/Grass/grassHalf_mid.png'));
        this.load.image('decor_bush', assetPath('Tiles/bush.png'));
        this.load.image('decor_mushroom', assetPath('Tiles/mushroomRed.png'));
        this.load.image('player_idle', assetPath('Players/Variable sizes/Blue/alienBlue_stand.png'));
        this.load.image('player_walk1', assetPath('Players/Variable sizes/Blue/alienBlue_walk1.png'));
        this.load.image('player_walk2', assetPath('Players/Variable sizes/Blue/alienBlue_walk2.png'));
        this.load.image('player_jump', assetPath('Players/Variable sizes/Blue/alienBlue_jump.png'));
        this.load.image('mirror', assetPath('Items/gemBlue.png'));
      }

      function create() {
        this.add.image(W / 2, H / 2, 'bg').setDisplaySize(W, H).setDepth(-5);

        platforms = this.physics.add.staticGroup();
        const tileSpacing = 70;
        const buildTile = (x, y, key = 'ground_mid') => {
          const tile = platforms.create(x, y, key);
          tile.setOrigin(0.5, 1).refreshBody();
          return tile;
        };

        const totalTiles = Math.ceil(W / tileSpacing) + 2;
        for (let i = 0; i < totalTiles; i++) {
          const x = i * tileSpacing - tileSpacing / 2;
          buildTile(x, H, i === 0 ? 'ground_left' : i === totalTiles - 1 ? 'ground_right' : 'ground_mid');
        }

        const platformLayouts = [
          { x: 180, y: H - 110, tiles: 3 },
          { x: 360, y: H - 180, tiles: 2 },
          { x: 520, y: H - 240, tiles: 3 },
          { x: 720, y: H - 300, tiles: 2 },
          { x: 880, y: H - 180, tiles: 3 },
          { x: 640, y: H - 140, tiles: 2 },
          { x: 320, y: H - 270, tiles: 2 },
          { x: 460, y: H - 330, tiles: 2 },
          { x: 780, y: H - 380, tiles: 3 }
        ];

        const buildPlatform = ({ x, y, tiles }) => {
          const startX = x;
          for (let i = 0; i < tiles; i++) {
            buildTile(startX + i * tileSpacing, y, 'ground_half');
          }
        };
        platformLayouts.forEach(buildPlatform);

        this.add.image(160, H - 80, 'decor_bush').setOrigin(0.5, 1).setScale(1.1).setDepth(-1);
        this.add.image(520, H - 90, 'decor_mushroom').setOrigin(0.5, 1).setScale(1).setDepth(-1);
        this.add.image(820, H - 80, 'decor_bush').setOrigin(0.5, 1).setScale(0.9).setDepth(-1);

        player = this.physics.add.sprite(80, H - 200, 'player_idle');
        player.setScale(0.6);
        player.setBounce(0.1).setCollideWorldBounds(true).setDepth(5);
        player.body.setSize(player.displayWidth * 0.45, player.displayHeight * 0.9);
        player.body.setOffset(player.displayWidth * 0.27, player.displayHeight * 0.1);
        this.physics.add.collider(player, platforms);

        this.anims.create({ key: 'idle', frames: [{ key: 'player_idle' }], frameRate: 1, repeat: -1 });
        this.anims.create({ key: 'run', frames: [{ key: 'player_walk1' }, { key: 'player_walk2' }], frameRate: 8, repeat: -1 });
        this.anims.create({ key: 'jump', frames: [{ key: 'player_jump' }], frameRate: 1, repeat: -1 });
        player.anims.play('idle');

        mirrors = this.physics.add.group({ allowGravity: false });
        const tiers = [
          { y: H - 170, startX: 180, step: 120, count: 5 },
          { y: H - 250, startX: 260, step: 150, count: 4 },
          { y: H - 330, startX: 340, step: 150, count: 4 },
          { y: H - 410, startX: 480, step: 160, count: 3 }
        ];
        const spawnPoints = [];
        tiers.forEach(({ y, startX, step, count }) => {
          for (let i = 0; i < count; i++) spawnPoints.push({ x: startX + i * step, y });
        });

        slugs.forEach((slug, idx) => {
          const point = spawnPoints[idx] ?? { x: 160 + idx * 60, y: H - 170 - (idx % 3) * 60 };
          const gem = mirrors.create(point.x, point.y, 'mirror');
          gem.setOrigin(0.5, 1).setScale(0.8);
          gem.body.setSize(gem.displayWidth * 0.6, gem.displayHeight * 0.6);
          gem.setData('slug', slug);
        });

        this.tweens.add({
          targets: mirrors.getChildren(),
          y: '+=10',
          duration: 1600,
          yoyo: true,
          repeat: -1,
          ease: 'Sine.easeInOut'
        });

        this.physics.add.overlap(player, mirrors, (_pl, m) => {
          const slug = m.getData('slug');
          unlock(slug);
          m.destroy();
        });

        cursors = this.input.keyboard.createCursorKeys();
      }

      function update() {
        const speed = 240;
        const onGround = player.body.blocked.down;

        if (cursors.left.isDown) {
          player.setVelocityX(-speed);
          player.setFlipX(true);
        } else if (cursors.right.isDown) {
          player.setVelocityX(speed);
          player.setFlipX(false);
        } else {
          player.setVelocityX(0);
        }

        if (cursors.up.isDown && onGround) {
          player.setVelocityY(-520);
        }

        if (!onGround) {
          player.anims.play('jump', true);
        } else if (Math.abs(player.body.velocity.x) > 10) {
          player.anims.play('run', true);
        } else {
          player.anims.play('idle', true);
        }
      }
    }
  </script>
</Base>
